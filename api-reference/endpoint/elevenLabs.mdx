
## Audio generation

Generating speech-to-speech involves a similar process to text-to-speech, but with some adjustments in the API parameters. Instead of providing text when calling the API, you provide the path to an audio file that you would like to convert from one voice to another. Hereâ€™s a modified version of your code to illustrate how to generate speech-to-speech using the given API:
<RequestExample>


```bash curl
curl --request POST \
  --url http://api.uiform.com/documents/process \
  --header 'Content-Type: application/json' \
  --data '{
  "model": "gpt-4o-2024-08-06",
  "json_schema": {},
  "stream": false,
  "seed": null,
  "temperature": 0,
  "documents": [
    {
      "id": "<string>",
      "name": "<string>",
      "size": 123,
      "mime_type": "<string>",
      "metadata": {
        "is_inline": false
      },
      "content": "<string>"
    }
  ],
  "prompting_context": {
    "document_structure": [
      {
        "content_summary": "Contains sender and receiver addresses",
        "title": "Invoice Header"
      }
    ],
    "domain_glossary": [
      {
        "definition": "Bill of Lading",
        "term": "B/L"
      }
    ],
    "other_context": [
      "Please consider the following instructions: ..."
    ],
    "regex_instructions": [
      {
        "description": "All potential VAT numbers in the documents",
        "name": "VAT Number",
        "pattern": "[Ff][Rr]\\s*(\\d\\s*){11}"
      }
    ],
    "user_info": {
      "email": "john.doe@domain.com",
      "first_name": "John",
      "last_name": "Doe"
    }
  },
  "ws_identifier": "<string>",
  "store_in_db": false
}'
```



```python python
from pydantic import BaseModel
from typing import Literal
from uiform.io import read_mime_data_from_file
from uiform.client import UiForm
client = UiForm(api_key="your_cube_api_key")

class User(BaseModel):
    full_name: str
    email: str
    age: int
    status: Literal["active", "inactive", "pending"]

pdf_document = read_mime_data_from_file("../notebooks/Luiz/data/example.PDF")

client.process_document(
    json_schema = User.model_json_schema(),
    documents = [pdf_document],
    model="gpt-4o-mini",
    prompting_context={
        "regex_instructions": {
            "name": "vat_number",
            "pattern": r"\b[A-Z]{2}\d{9}\b",
            "description": "VAT number in the format XX999999999"
        }
    }
)
```

</RequestExample>


<ResponseExample>

```json 200
{
  "model": "gpt-4o-2024-08-06",
  "json_schema": {},
  "stream": false,
  "seed": null,
  "temperature": 0,
  "documents": [
    {
      "id": "<string>",
      "name": "<string>",
      "size": 123,
      "mime_type": "<string>",
      "metadata": {
        "is_inline": false
      }
    }
  ],
  "prompting_context": {
    "document_structure": [
      {
        "content_summary": "Contains sender and receiver addresses",
        "title": "Invoice Header"
      }
    ],
    "domain_glossary": [
      {
        "definition": "Bill of Lading",
        "term": "B/L"
      }
    ],
    "other_context": [
      "Please consider the following instructions: ..."
    ],
    "regex_instructions": [
      {
        "description": "All potential VAT numbers in the documents",
        "name": "VAT Number",
        "pattern": "[Ff][Rr]\\s*(\\d\\s*){11}"
      }
    ],
    "user_info": {
      "email": "john.doe@domain.com",
      "first_name": "John",
      "last_name": "Doe"
    }
  },
  "ws_identifier": "<string>",
  "store_in_db": false,
  "response": "<any>",
  "likelihoods": "<any>",
  "regex_instruction_results": [
    {
      "instruction": {
        "name": "<string>",
        "pattern": "<string>",
        "description": "<string>"
      },
      "hits": [
        "<string>"
      ]
    }
  ],
  "prompting_context_message": "",
  "usage": {
    "model": "<string>",
    "input_tokens": 123,
    "output_tokens": 123,
    "cost": 123
  }
}
```

```json 422
{
  "detail": [
    {
      "loc": [
        "<string>"
      ],
      "msg": "<string>",
      "type": "<string>"
    }
  ]
}
```


</ResponseExample>



```python
# Import necessary libraries
import requests  # Used for making HTTP requests
import json  # Used for working with JSON data

# Define constants for the script
CHUNK_SIZE = 1024  # Size of chunks to read/write at a time
XI_API_KEY = "<xi-api-key>"  # Your API key for authentication
VOICE_ID = "<voice-id>"  # ID of the voice model to use
AUDIO_FILE_PATH = "<path>"  # Path to the input audio file
OUTPUT_PATH = "output.mp3"  # Path to save the output audio file

# Construct the URL for the Speech-to-Speech API request
sts_url = f"https://api.elevenlabs.io/v1/speech-to-speech/{VOICE_ID}/stream"

# Set up headers for the API request, including the API key for authentication
headers = {
    "Accept": "application/json",
    "xi-api-key": XI_API_KEY
}

# Set up the data payload for the API request, including model ID and voice settings
# Note: voice settings are converted to a JSON string
data = {
    "model_id": "eleven_english_sts_v2",
    "voice_settings": json.dumps({
        "stability": 0.5,
        "similarity_boost": 0.8,
        "style": 0.0,
        "use_speaker_boost": True
    })
}

# Set up the files to send with the request, including the input audio file
files = {
    "audio": open(AUDIO_FILE_PATH, "rb")
}

# Make the POST request to the STS API with headers, data, and files, enabling streaming response
response = requests.post(sts_url, headers=headers, data=data, files=files, stream=True)

# Check if the request was successful
if response.ok:
    # Open the output file in write-binary mode
    with open(OUTPUT_PATH, "wb") as f:
        # Read the response in chunks and write to the file
        for chunk in response.iter_content(chunk_size=CHUNK_SIZE):
            f.write(chunk)
    # Inform the user of success
    print("Audio stream saved successfully.")
else:
    # Print the error message if the request was not successful
    print(response.text)
```
## Voices
We offer 1000s of voices in 29 languages. Visit the [Voice Lab](https://elevenlabs.io/voice-lab) to explore our pre-made voices or [clone your own](https://elevenlabs.io/voice-cloning). Visit the [Voices Library](https://elevenlabs.io/voice-library) to see voices generated by ElevenLabs users.

## Supported languages
Our STS API is multilingual and currently supports the following languages:

`Chinese, Korean, Dutch, Turkish, Swedish, Indonesian, Filipino, Japanese, Ukrainian, Greek, Czech, Finnish, Romanian, Russian, Danish, Bulgarian, Malay, Slovak, Croatian, Classic Arabic, Tamil, English, Polish, German, Spanish, French, Italian, Hindi and Portuguese`. 

To use them, simply provide the input audio in the language of your choice.

---