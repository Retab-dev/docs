# UiForm Supported JSON Schemas

## Supported Types

The following types are supported:

- **String**
- **Number**
- **Boolean**
- **Integer**
- **Object**
- **Array**
- **Enum**
- **anyOf**

The `anyOf` key is only supported for nullable fields. To assign a field as nullable, you can use the following example:

### Good Example

```json
{
  "type": "object",
  "properties": {
    "exampleField": {
      "anyOf": [
        { "type": "string" },
        { "type": "null" }
      ]
    }
  },
  "required": ["exampleField"]
}
```

### Bad Example

```json
{
  "type": "object",
  "properties": {
    "exampleField": {
      "anyOf": [
        { "type": "string" },
        { "type": "number" }
      ]
    }
  },
  "required": ["exampleField"]
}
```

This example is problematic because it allows multiple conflicting types without clear validation logic.

## Custom Annotations for Inference

For enhanced precision, we support three special custom annotations in the JSON schema:

1. **`X-SystemPrompt`**: The system prompt that will be sent to the underlying LLM.
2. **`X-LLMDescription`**: If present, it replaces the current property description with a more detailed one, helping the LLM better understand the property and extract it accurately.
3. **`X-ReasoningDescription`**: For fields that are harder to extract, this annotation generates a sibling field of type `string` to act as a reasoning sandbox. This helps the LLM provide better outputs since it is a language-based model.

### Examples of `X-ReasoningDescription`

This annotation can be tricky if not properly understood, so hereâ€™s a complete example:

```json
{
  "$defs": {
    "ArrayItem": {
      "X-ReasoningDescription": "This is the Array Item reasoning description",
      "properties": {
        "array_item_string_field": {
          "X-ReasoningDescription": "This is the array_item_string_field reasoning description",
          "description": "array_item_string_field description",
          "title": "Array Item String Field",
          "type": "string"
        }
      },
      "required": ["array_item_string_field"],
      "title": "ArrayItem",
      "type": "object"
    },
    "SimpleObject": {
      "properties": {
        "object_integer_field": {
          "description": "object_integer_field description",
          "title": "Object Integer Field",
          "type": "integer"
        },
        "object_string_field": {
          "X-ReasoningDescription": "This is the object_string_field reasoning description",
          "description": "object_string_field description",
          "title": "Object String Field",
          "type": "string"
        }
      },
      "required": ["object_integer_field", "object_string_field"],
      "title": "SimpleObject",
      "type": "object"
    }
  },
  "X-ReasoningDescription": "This is the root reasoning description",
  "X-SystemPrompt": "This is the system prompt",
  "properties": {
    "my_string_field": {
      "X-ReasoningDescription": "This is the my_string_field reasoning description",
      "description": "my_string_field description",
      "title": "My String Field",
      "type": "string"
    },
    "my_simple_object": {
      "$ref": "#/$defs/SimpleObject",
      "X-ReasoningDescription": "This is the my_simple_object reasoning description",
      "description": "my_simple_object description"
    },
    "my_array": {
      "X-ReasoningDescription": "This is my_array reasoning description",
      "description": "This is my_array description",
      "items": {
        "$ref": "#/$defs/ArrayItem"
      },
      "title": "My Array",
      "type": "array"
    }
  },
  "required": ["my_string_field", "my_simple_object", "my_array"],
  "title": "BasicBaseModel",
  "type": "object"
}
```

### Example Output

This schema should validate objects like this:

```json
{
  "my_string_field": "Example string value.",
  "my_simple_object": {
    "object_integer_field": 42,
    "object_string_field": "Example string in object."
  },
  "my_array": [
    {
      "array_item_string_field": "Example string in array item."
    }
  ]
}
```

However, the LLM might produce additional reasoning fields for better extraction, such as:

```json
{
  "reasoning___root": "Root reasoning context.",
  "reasoning___my_string_field": "Reasoning for my_string_field.",
  "my_string_field": "Example string value.",
  "reasoning___my_simple_object": "Reasoning for my_simple_object.",
  "my_simple_object": {
    "object_integer_field": 42,
    "reasoning___object_string_field": "Reasoning for object_string_field.",
    "object_string_field": "Example string in object."
  },
  "reasoning___my_array": "Reasoning for my_array.",
  "my_array": [
    {
      "reasoning___array_item_string_field": "Reasoning for array_item_string_field.",
      "array_item_string_field": "Example string in array item."
    }
  ]
}
```

As you can see, apart from the "reasoning___" fields, the LLM output follows the same structure as your supplied schema.

## Python's Pydantic BaseModel Support

The conversion of Pydantic's BaseModel to model_json_schema is straightforward:

```python
# your BaseModel instantiation ...

YourBaseModel.model_json_schema()
```

However, to properly access the custom annotations, you may need to set the `json_schema_extra` within the `pydantic.Field` class.

Here is a minimalistic example with everything you should need:

### Minimalistic Example

```python
import json
from pydantic import BaseModel, Field

# Main Data model
class BasicBaseModel(BaseModel):
    # Add a json_schema_extra to the root
    class Config:
        json_schema_extra = {
            "X-SystemPrompt": "This is the system prompt",
            "X-ReasoningDescription": "This is the root reasoning description"
        }

    class SimpleObject(BaseModel):
        object_integer_field: int = Field(..., description="Simple integer field description",
                                          json_schema_extra={"X-LLMDescription": "This is the object integer field LLM description"})
        object_string_field: str = Field(...,
                                         description="Simple string field description",
                                         json_schema_extra={"X-ReasoningDescription": "This is the object string field reasoning description"})

    class ArrayItem(BaseModel):
        class Config:
            json_schema_extra = {"X-ReasoningDescription": "This is the Array Item reasoning description"}
        
        array_item_string_field: str = Field(..., description="Array Item String Field description")

    my_string_field: str = Field(..., description="My String Field description")
    my_simple_object: SimpleObject = Field(..., description="Simple object description")
    my_array: list[ArrayItem] = Field(...,
                                      description="This is the array description",
                                      json_schema_extra={"X-ReasoningDescription": "This is the array reasoning description"}
                                      )
if __name__ == "__main__":
    with open("path_to_file.json", "w") as f:
        json.dump(BasicBaseModel.model_json_schema(), f, indent=4)
```

The content of `path_to_file.json` is actually the schema from [Examples of X-ReasoningDescription](#examples-of-x-reasoningdescription).
